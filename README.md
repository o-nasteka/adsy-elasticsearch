# Оптимізація агрегацій у Elasticsearch при великому обсязі даних

## Проблема

У MySQL-таблиці понад 500 000 записів. Потрібно виконувати агрегацію по полю з більш ніж 100 000 унікальних значень. Використання Elasticsearch для агрегації стикається з проблемами продуктивності:

- Після агрегації отримується 3 000 груп, кожна з яких має ще 10 підгруп.
- У підсумку: 30 000 результатів.
- Це призводить до перевантаження heap-пам’яті JVM і значного падіння продуктивності.

## Причина

- Elasticsearch зберігає агреговані ключі у heap.
- Велика кількість унікальних значень + вкладені агрегації = високі вимоги до пам’яті.

## Рекомендовані рішення

### 1. Composite aggregation
- Використовувати пагінацію результатів агрегацій за допомогою `after_key`.
- Поступово отримувати всі унікальні значення без перенавантаження пам’яті.

### 2. Обмеження terms aggregation
- Обмежити параметри `size` та `shard_size`.
- Приклад:
```json
{
  "terms": {
    "field": "your_field.keyword",
    "size": 1000,
    "shard_size": 1200,
    "execution_hint": "map"
  }
}
```

### 3. Передагрегація (pre-aggregation)
- Зберігати агреговані дані в окремому індексі або кеші.
- Оновлювати за розкладом (наприклад, щогодини).

## Додаткові архітектурні варіанти масштабування

### 4. Стратифікована агрегація
Розбиття агрегацій на кілька рівнів (наприклад, спочатку по shard, потім злиття). Реалізація через composite aggregation + обробку на бекенді.

### 5. Rollup jobs
Вбудована функція Elasticsearch для періодичної агрегації. Дані зберігаються в окремому rollup-індексі. Підходить для звітів, дашбордів і історичних зведень.

### 6. Перехід на OLAP-систему
Використання систем, оптимізованих для агрегацій: ClickHouse, Druid, Apache Pinot. Дані реплікуються з MySQL або Elasticsearch. Потенційно ізольована архітектура (без зміни основного застосунку).

### 7. Кешування агрегатів
Кешування результатів агрегацій у Redis або окремій таблиці. Добре працює для часто повторюваних запитів або попередньо оброблених даних. Оновлення через cron або queue.

## Порівняльна таблиця підходів

| Підхід                      | Навантаження | Гнучкість | Час впровадження |
|----------------------------|--------------|-----------|------------------|
| Composite aggregation      | Низьке       | Висока    | Низький          |
| Terms + shard_size         | Середнє      | Середня   | Дуже низький     |
| Передагрегація             | Дуже низьке  | Висока    | Середній         |
| Rollup jobs                | Низьке       | Низька    | Низький          |
| OLAP (ClickHouse, Druid)   | Низьке       | Висока    | Високий          |
| Кешування результатів      | Дуже низьке  | Висока    | Низький          |

##